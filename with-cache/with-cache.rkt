#lang racket/base

;; lightweight, filesystem-based caching

(provide
  *use-cache?*
  *current-cache-directory*
  *current-cache-keys*
  *keys-equal?*
  cachefile
  with-cache
  parent-directory-exists?
  with-cache-logger
  get-with-cache-version
)

(require
  (only-in racket/file file->value call-with-file-lock/timeout make-lock-file-name make-directory*)
  (only-in racket/path path-only)
  (only-in racket/date date-display-format current-date date->string)
  (only-in racket/serialize serialize deserialize)
  (only-in racket/port open-output-nowhere)
  (only-in setup/getinfo get-info)
)

;; =============================================================================

(define (get-with-cache-version)
  ((get-info '("with-cache")) 'version))

(define no-keys (string->symbol (string-append "no-keys:" (get-with-cache-version))))

(define *use-cache?* (make-parameter #t))
(define *current-cache-directory* (make-parameter (build-path (current-directory) "compiled" "with-cache")))
(define *current-cache-keys* (make-parameter (list get-with-cache-version)))
(define *keys-equal?* (make-parameter equal?))

(define-logger with-cache)

(define (no-keys? x)
  (eq? x no-keys))

;; -----------------------------------------------------------------------------

(define (cachefile ps)
  (define ccd (*current-cache-directory*))
  (unless (directory-exists? ccd)
    (make-directory* ccd))
  (build-path ccd ps))

(define (with-cache cache-file
                    thunk
                    #:use-cache? [use? (*use-cache?*)]
                    #:keys [keys (*current-cache-keys*)]
                    #:keys-equal? [keys-equal? (*keys-equal?*)]
                    #:read [read-proc deserialize]
                    #:write [write-proc serialize])
  (let* (;; resolve read&write functions
         [read-proc (read/keys read-proc keys keys-equal?)]
         [write-proc (write/keys write-proc keys)])
    (or ;; -- read from cachefile
        (and use?
             (file-exists? cache-file)
             (with-handlers ([exn:fail? (cache-read-error cache-file)])
               (log-with-cache-info "reading cache file '~a'..." cache-file)
               (cond
                [(read-proc (call-with-atomic-input-file cache-file read))
                 => (λ (read-val)
                      (log-with-cache-info "successfully read cache file '~a'" cache-file)
                      read-val)]
                [else #f])))
        ;; -- write new cache file
        (let ([r (thunk)])
          (when use?
            (define val-to-write
              (with-handlers ([exn:fail? (λ (exn) (raise-user-error 'with-cache "Internal error: failed to make writable value from result '~e'" r))])
                (write-proc r)))
            (log-with-cache-info "writing cache file '~a'" cache-file)
            (with-handlers ([exn:fail? (cache-write-error cache-file)])
              (call-with-atomic-output-file cache-file
                (λ (out)
                  (parameterize ([date-display-format 'iso-8601])
                    (fprintf out ";; This file was generated by the `with-cache` library on ~a~n" (date->string (current-date))))
                  (writeln val-to-write out)
                  (log-with-cache-info "successfully wrote to cache file '~a'" cache-file)))))
          r))))

;; -----------------------------------------------------------------------------

(define (exn->string ex)
  (format "got exception:~n~a" (exn-message ex)))

(define (cache-read-error cache-file) ; (-> Path-String (-> Exception #f))
  (lambda (ex)
    (define msg-prefix (format "Failed to read cache file '~a'" cache-file))
    (log-with-cache-error (string-append msg-prefix ", " (exn->string ex)))
    #f))

(define (cache-write-error cache-file) ; (-> Path-String (-> Exception #f))
  (lambda (ex)
    (define msg-prefix (format "Failed to write cache file '~a'" cache-file))
    (define err-prefix (format "Internal error: failed to delete malformed cache file '~a'" cache-file))
    (log-with-cache-error (string-append msg-prefix ", " (exn->string ex)))
    (define (err-handler e)
      (raise-user-error 'with-cache (string-append err-prefix ", " (exn->string e))))
    (with-handlers ([exn:fail:filesystem? err-handler])
      (when (file-exists? cache-file)
        (delete-file cache-file)))
    #f))

(define (call-with-atomic-input-file filename success-proc)
  (call/atomic filename (λ () (call-with-input-file filename success-proc))))

(define (call-with-atomic-output-file filename success-proc)
  (call/atomic filename (λ () (call-with-output-file filename success-proc #:exists 'replace))))

(define (call/atomic filename success-thunk)
  (define lockfile (make-lock-file-name
                     (build-path (find-system-path 'temp-dir)
                                 (format "with-cache~a" (equal-hash-code filename)))))
  (call-with-file-lock/timeout filename
                               'exclusive
                               success-thunk
                               (λ ()
                                 (raise (exn:fail:filesystem
                                          (format "with-cache: Failed to lock file '~a', delete the lock '~a' and try again." filename lockfile)
                                          (current-continuation-marks))))
                               #:lock-file lockfile))

(define (parent-directory-exists? ps)
  (and (path-string? ps)
       (let ([dir (path-only ps)])
         (or (not dir) (directory-exists? dir)))))

(define (read/keys read-proc keys keys-equal?)
  (if (and keys (not (null? keys)))
    (λ (v)
      (and (pair? v)
           (list? (car v))
           (keys-equal? (car v) (keys->vals keys))
           (read-proc (cdr v))))
    (λ (v)
      (and (pair? v)
           (no-keys? (car v))
           (read-proc (cdr v))))))

(define (write/keys write-proc keys)
  (if (and keys (not (null? keys)))
    (λ (v)
      (cons (keys->vals keys) (write-proc v)))
    (λ (v)
      (cons no-keys (write-proc v)))))

(define (keys->vals key-thunks)
  (for/list ([t (in-list key-thunks)])
    (t)))

